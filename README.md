# INTRODUCTION
Many applications require exchange of information over the internet in a secure manner. The main objective of this project is to develop a k out of n fast secret sharing scheme to transfer secret images (using encryption algorithms) using n number of shares such that any k out of the n shares can be combined to reconstruct the secret images using a valid key and disallowing revelation of the secret image if the number of shares falls below k. Hence this ensures authentication of share holders and
eradicates the problem of misusing the shares. The regenerated image has better visual quality and the recovery time is also very less as it requires simple addition and XOR operations. This algorithm is designed such that it supports both gray and color images.

![image](https://user-images.githubusercontent.com/70642284/197511191-c89b6856-0fde-446c-a8fd-cd491f253075.png)


#  CHALLENGES
* There are various algorithms already implemented which involve the dividing the secret into n shares and then recreating the secret using any of the k shares.
* However one of the challenges regarding the algorithm is that if anybody steals the share of any participant, then he may be able to access the secret information.
* Also there may not be any form of authentication for the participant who actually has the share. Hence the secret is very much vulnerable.
* The other challenges involve managing the computation cost of distribbution and recovery phases. There are algorithms like Shamir Secret Sharing Algorithm which involve very high computation cost both for recovery and distribution.

# PROPOSED ALGORITHM
The proposed algorithm not only ensures the authentication of each particiapnt but also provides additional security for each of the shares.
Firstly a random key having the same shape as the secret image is generated and is with the dealer (dealer key).
```
dealer_key[i][j][k] = (np.random.randint(0,255))
```

Then the secret image is xored with the random key and an encrypted image R is generated
```
encrypted_im[i][j][k] = im[i][j][k]^rand_key[i][j][k]
```
The encrypted image is divided by k (number of required shares) to get the required share of each registered participant R1.
```
R1[i][j][k] = int(en_image[i][j][k]//int(sh))
R1_remainder[i][j][k] = en_image[i][j][k]%int(sh)
```

Now each of the participants is given a unique id for authentication U(i). The unique ids are converted to encrypted ids using the following algorithm:
* Convert the unique id to 8 bit binary number. Let's say the first 4 bits are MSB (most significant bits) and last 4 bits are LSB (least significant bits).
* Now the encrypted id E(i) is generated by assigning :
```
MSB(E[i]) = MSB(U(i)) ^ LSB(U(i))
LSB(E[i]) = LSB(U(i))
```
* Converting the 8 bit binary encrypted id back to decimal based integer

Then for each participant its share S(i) is generated by circularly left shifting each pixel value in R1, E(i) times. Then the encrypted id of each participant is encrypted in the respective participant's share image in the first 8 pixels. Hence the final share is generated and is given to the participant.
```
S(i) = encode_share(leftCircularShift(R1, E(i)))
```
## 3 Generated Shares in a (7,3) secret sharing scheme
<img src="https://user-images.githubusercontent.com/70642284/197508603-eb0ee43c-1190-4a33-a598-8febf53a0935.png" data-canonical-src="https://gyazo.com/eb5c5741b6a9a16c692170a41a49c858.png" width="300" height="400" />  <img src="https://user-images.githubusercontent.com/70642284/197510442-df05de96-80a0-45ba-a5e8-1c1e9ce89690.png" data-canonical-src="https://gyazo.com/eb5c5741b6a9a16c692170a41a49c858.png" width="300" height="400" />  <img src="https://user-images.githubusercontent.com/70642284/197510457-863b7484-8969-420d-bc0a-df6d50709e58.png" data-canonical-src="https://gyazo.com/eb5c5741b6a9a16c692170a41a49c858.png" width="300" height="400" />

Now each of the ith participants has a unique id  U(i) and a share S(i). So even if any person steals the share of any participant, he will not be able to get the unique id of the authorized person and hence will not be able to retrieve the image from the dealer. During the start of recovery phase we check if the encypted id generated by the unique id, using the same above algorithm matches the encrypted id retreived from the first 8 pixels of the share. If both match then the participant is authenticated.

Once all the participants are verified, the share of each participant is circularly right shifted E(i) times to get the original encrypted image share R1.
```
R1(i) = rightCircularShift(S(i), E(i))
```
The original encrypted image is reconstructed by adding all the k shares along with the remainder matrix.
```
 retreived_encrypted_image[i][j][k] += retreived_shares[s][i][j][k]
 retreived_encrypted_image[i][j][k] += rem[i][j][k]
```
Finally the original secret image is extracted by xoring the retrieved encrypted image with the dealer key :
```
secret_im[i][j][k] =  retreived_encrypted_image[i][j][k]^rand_key[i][j][k]
```
Hence the secret image is retrieved.

<img src="https://user-images.githubusercontent.com/70642284/197511301-64de4f87-dbe4-4656-b468-4483a9416312.png" data-canonical-src="https://gyazo.com/eb5c5741b6a9a16c692170a41a49c858.png" width="300" height="400" />

# RELATED WORK
* Recursive Information Hiding Technique included by Sandeep Katta in his work https://shareok.org/bitstream/handle/11244/8178/KATTA_okstate_0664M_11654.pdf?sequence=1

* K-N secret sharing algorithm for colored images using random numbers by Shayamalendu Kandar and Arnab Maiti in their paper https://www.researchgate.net/publication/50946075_K-N_SECRET_SHARING_VISUAL_CRYPTOGRAPHY_SCHEME_FOR_COLOR_IMAGE_USING_RANDOM_NUMBER

* Shamir's Secret sharing algorithm : https://www.geeksforgeeks.org/shamirs-secret-sharing-algorithm-cryptography/

* Sharing Secret Image with Encapsulated shares in Visual Cryptography : https://www.sciencedirect.com/science/article/pii/S1877050915032445

# APPLICATIONS
* A company needs to secure their vault's code. A single person knowing the code could act dishonestly or be unavailable when the vaults needs to be opened. SSS can be used in this situation to generate shares from the vault's code which are distributed to executives in the Company. The selected threshold and number of shares given to each executive can be select such that the vault is accessible only by (groups of) authorized individuals. If less than the threshold of shares were compromised, these shares alone would not be enough to determine the code.

* International government agencies can use this method to transmit secret information safely and securely ensuring confidentiality of their information.

# CONCLUSION
Visual cryptography provides a secure way to transfer images. The advantage of visual cryptography is that it exploits human eyes to decrypt secret images with no computation required.
Visual Cryptography allows easy decoding of the secret image by a simple stacking of the printed share transparencies.
As visual cryptography schemes operate at the pixel levels, each pixel on one share must be matched correctly with the corresponding pixel on the other share. Superimposing the shares with even a slight change in the alignment results in a drastic degradation in the quality of the
reconstructed image. 


