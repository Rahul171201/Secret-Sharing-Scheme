# INTRODUCTION
Many applications require exchange of information over the internet in a secure manner. The main objective of this project is to develop a k out of n fast secret sharing scheme to transfer secret images (using encryption algorithms) using n number of shares such that any k out of the n shares can be combined to reconstruct the secret images using a valid key and disallowing revelation of the secret image if the number of shares falls below k. Hence this ensures authentication of share holders and
eradicates the problem of misusing the shares. The regenerated image has better visual quality and the recovery time is also very less as it requires simple addition and XOR operations. This algorithm is designed such that it supports both gray and color images.

![image](https://user-images.githubusercontent.com/70642284/197511191-c89b6856-0fde-446c-a8fd-cd491f253075.png)


#  CHALLENGES
* There are various algorithms already implemented which involve the dividing the secret into n shares and then recreating the secret using any of the k shares.
* However one of the challenges regarding the algorithm is that if anybody steals the share of any participant, then he may be able to access the secret information.
* Also there may not be any form of authentication for the participant who actually has the share. Hence the secret is very much vulnerable.
* The other challenges involve managing the computation cost of distribbution and recovery phases. There are algorithms like Shamir Secret Sharing Algorithm which involve very high computation cost both for recovery and distribution.

# PROPOSED ALGORITHM
The proposed algorithm not only ensures the authentication of each particiapnt but also provides additional security for each of the shares.
Firstly a random key having the same shape as the secret image is generated and is with the dealer (dealer key).
```
dealer_key[i][j][k] = (np.random.randint(0,255))
```

Then the secret image is xored with the random key and an encrypted image R is generated
```
encrypted_im[i][j][k] = im[i][j][k]^rand_key[i][j][k]
```
The encrypted image is divided by k (number of required shares) to get the required share of each registered participant R1.
```
R1[i][j][k] = int(en_image[i][j][k]//int(sh))
R1_remainder[i][j][k] = en_image[i][j][k]%int(sh)
```

Now each of the participant is given a unique id for authentication U(i). The unique ids are converted to encryted ids using the following algorithm:
* Convert the unique id to 8 bit binary number. Let's say the first 4 bits are MSB (most significant bits) and last 4 bits are LSB (least significant bits).
* Now the encrypted id E(i) is generated by assigning :
```
MSB(E[i]) = MSB(U(i)) ^ LSB(U(i))
LSB(E[i]) = LSB(U(i))
```
* Converting the 8 bit binary encrypted id back to decimal based integer

Then for each participant its share S(i) is generated by circularly left shifting each pixel value in R1, E(i) times. Then the encrypted id of each participant is encrypted in the respective participant's share image in the first 8 pixels. Hence the final share is generated and is given to the participant.
```
S(i) = encode_share(leftCircularShift(R1, E(i)))
```
## 3 Generated Shares in a (7,3) secret sharing scheme
<img src="https://user-images.githubusercontent.com/70642284/197508603-eb0ee43c-1190-4a33-a598-8febf53a0935.png" data-canonical-src="https://gyazo.com/eb5c5741b6a9a16c692170a41a49c858.png" width="300" height="400" />  <img src="https://user-images.githubusercontent.com/70642284/197510442-df05de96-80a0-45ba-a5e8-1c1e9ce89690.png" data-canonical-src="https://gyazo.com/eb5c5741b6a9a16c692170a41a49c858.png" width="300" height="400" />  <img src="https://user-images.githubusercontent.com/70642284/197510457-863b7484-8969-420d-bc0a-df6d50709e58.png" data-canonical-src="https://gyazo.com/eb5c5741b6a9a16c692170a41a49c858.png" width="300" height="400" />

Now each of the ith participant has a unique id  U(i) and a share S(i). so even if any person steals the share of any participant, he will not be able to get the unique id of the authorized person and hence will not be able to retreive the image from the dealer. During the start of recovery phase we check if the encypted id generated by the unique id, using the same above algorithm matches the encrypted id retreived from the first 8 pixels of the share. If both match then the participant is authenticated.

Once all the participants are verified, the share of each participant is circularly right shifted E(i) times to get the original encrypted image share R1.
```
R1(i) = rightCircularShift(S(i), E(i))
```
The original encrypted image is reconstructed by adding all the k shares along with the remainder matrix.
```
 retreived_encrypted_image[i][j][k] += retreived_shares[s][i][j][k]
 retreived_encrypted_image[i][j][k] += rem[i][j][k]
```
Finally the original secret image is extracted by xoring the retreived encrypted image with the dealer key :
```
secret_im[i][j][k] = encrypted_im[i][j][k]^rand_key[i][j][k]
```
Hence the secret image is retreived.

<img src="https://user-images.githubusercontent.com/70642284/197511301-64de4f87-dbe4-4656-b468-4483a9416312.png" data-canonical-src="https://gyazo.com/eb5c5741b6a9a16c692170a41a49c858.png" width="300" height="400" />
